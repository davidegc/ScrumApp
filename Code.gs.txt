const SPREADSHEET_ID = 'TU_ID_DE_HOJA_DE_CALCULO_AQUI'; // Mant칠n tu ID aqu칤

const FEATURES_SHEET_NAME = 'Features';
const USER_STORIES_SHEET_NAME = 'UserStories';
const DEPENDENCIES_SHEET_NAME = 'Dependencies';
const ANNOUNCEMENTS_SHEET_NAME = 'Announcements';
const CONFIG_SHEET_NAME = 'Config';
const MOODS_SHEET_NAME = 'Moods';
const IMPEDIMENTS_SHEET_NAME = 'Impediments';
const QUICKLINKS_SHEET_NAME = 'QuickLinks';
const UPCOMING_EVENTS_SHEET_NAME = 'UpcomingEvents';
const COMMUNICATIONS_SHEET_NAME = 'Comunicados';

const APP_CONFIG_DEFAULTS = {
  APP_TITLE: 'Scrum App',
  APP_SUBTITLE: 'Panel de Seguimiento 츼gil',
  HELP_CHAT_URL: '#',
  TEAM_MESSAGE_CARD_TITLE: 'Comunicados del Equipo',
  IMPEDIMENT_NOTIFICATION_EMAIL: '',
  CALENDAR_ID_SHEET: UPCOMING_EVENTS_SHEET_NAME,
  MAX_CALENDAR_EVENTS: 10,
  TEAM_MOOD_DEFAULT_EMOJI: "游땕",
  APP_DATA_SOURCE_URL: '#',
  UPCOMING_EVENTS_EDIT_URL: '#',
  COMMUNICATIONS_EDIT_URL: '#',
  QUICKLINKS_EDIT_URL: '#'
};

/**
 * Funci칩n principal que se ejecuta cuando se accede a la aplicaci칩n web.
 * @param {Object} e - El objeto de evento.
 * @return {HtmlOutput} El servicio HTML para renderizar la p치gina.
 */
function doGet(e) {
  return HtmlService.createTemplateFromFile('Index').evaluate()
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.DEFAULT);
}

/**
 * Incluye el contenido de otro archivo HTML (para plantillas).
 * @param {string} filename - El nombre del archivo HTML a incluir.
 * @return {string} El contenido del archivo HTML.
 */
function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

/**
 * Obtiene todos los datos necesarios de las hojas de c치lculo.
 * @return {Object} Un objeto con todos los datos de la aplicaci칩n o un objeto de error.
 */
function getAllSheetData() {
  let ss;
  Logger.log(`Iniciando getAllSheetData para SPREADSHEET_ID: ${SPREADSHEET_ID}`);
  const defaultReturnValue = {
    error: null, features: [], announcements: [], config: { ...APP_CONFIG_DEFAULTS }, quickLinks: [],
    impediments: [], currentUserEmail: getActiveUserEmailSafely(),
    podiumDataFeatures: [], podiumDataUserStories: [], podiumDataDependencies: [],
    availableQs: [], availableSprints: [],
    allFeaturesForImpediments: [], nonDeployedUserStories: [], upcomingEvents: [],
    communications: []
  };

  try {
    if (!SPREADSHEET_ID || SPREADSHEET_ID === 'TU_SPREADSHEET_ID_AQUI' || SPREADSHEET_ID.length < 20) {
      const errMsg = `Error Cr칤tico: SPREADSHEET_ID no est치 configurado o es inv치lido. ID actual: "${SPREADSHEET_ID}"`;
      console.error(errMsg);
      Logger.log(errMsg);
      return { ...defaultReturnValue, error: errMsg };
    }
    ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    if (!ss) {
      const errMsg = `Error Cr칤tico: No se pudo abrir Spreadsheet con ID: ${SPREADSHEET_ID}. Verifica ID, existencia y permisos.`;
      console.error(errMsg);
      Logger.log(errMsg);
      return { ...defaultReturnValue, error: errMsg };
    }
    Logger.log(`Spreadsheet "${ss.getName()}" abierto.`);

    const getDataFromSheet = (sheetName, defaultValue = []) => {
      const sheet = ss.getSheetByName(sheetName);
      if (!sheet) {
        Logger.log(`Advertencia: Hoja "${sheetName}" no encontrada. Usando valor por defecto.`);
        return defaultValue;
      }
      return getSheetDataAsObjects(sheet, sheetName);
    };

    const configSheet = ss.getSheetByName(CONFIG_SHEET_NAME);
    const configSheetData = configSheet ? getSheetDataAsObjects(configSheet, CONFIG_SHEET_NAME) : [];
    let config = { ...APP_CONFIG_DEFAULTS };

    if (Array.isArray(configSheetData)) {
      configSheetData.forEach(item => {
        if (item && typeof item.Key !== 'undefined' && item.Value !== null && typeof item.Value !== 'undefined') {
          let value = item.Value;
          if (value instanceof Date) value = value.toISOString();
          if (item.Key === 'SPRINT_INFO_YEAR' && (value === 25 || String(value).trim() === "25")) value = 2025;

          if (item.Key === 'SPRINT_INFO_YEAR' || item.Key === 'SPRINT_INFO_NUMBER_IN_QUARTER' || item.Key === 'MAX_CALENDAR_EVENTS') {
            config[item.Key] = Number(value);
          } else {
            config[item.Key] = value;
          }
        }
      });
    }
    if (typeof config.MAX_CALENDAR_EVENTS === 'undefined' || config.MAX_CALENDAR_EVENTS < 1) {
      config.MAX_CALENDAR_EVENTS = 10;
    }
    Logger.log(`Configuraci칩n cargada: ${JSON.stringify(config)}`);

    let allAnnouncements = getDataFromSheet(ANNOUNCEMENTS_SHEET_NAME, []);
    let announcementsToClient = allAnnouncements.sort((a, b) => (Number(a.Order) || Infinity) - (Number(b.Order) || Infinity));

    const quickLinksData = getDataFromSheet(QUICKLINKS_SHEET_NAME, []);
    let featuresData = getDataFromSheet(FEATURES_SHEET_NAME, []);
    const userStoriesData = getDataFromSheet(USER_STORIES_SHEET_NAME, []);
    const dependenciesData = getDataFromSheet(DEPENDENCIES_SHEET_NAME, []);
    const impedimentsData = getDataFromSheet(IMPEDIMENTS_SHEET_NAME, []);

    let communicationsData = getDataFromSheet(COMMUNICATIONS_SHEET_NAME, []);
    communicationsData = communicationsData
      .filter(comm => comm.Message && String(comm.Message).trim() !== "")
      .sort((a, b) => {
        const dateA = a.Date ? new Date(a.Date) : new Date(0);
        const dateB = b.Date ? new Date(b.Date) : new Date(0);
        return dateB.getTime() - dateA.getTime();
      });
    Logger.log(`Comunicados procesados: ${communicationsData.length}`);


    const allFeaturesForImpediments = featuresData
      .map(f => ({ ID: f.ID, Name: f.Name }))
      .sort((a, b) => (a.Name || "").localeCompare(b.Name || ""));

    const nonDeployedUserStories = userStoriesData
      .filter(us => String(us.Status || '').trim().toLowerCase() !== 'deployed')
      .map(us => ({ ID: us.ID, Name: us.Name, FeatureID: us.FeatureID }))
      .sort((a, b) => (a.Name || "").localeCompare(b.Name || ""));


    if (featuresData.length > 0) {
      featuresData = featuresData.map(feature => {
        const featureIdStr = String(feature.ID);
        let associatedUserStories = userStoriesData.filter(us => String(us.FeatureID) === featureIdStr);
        let associatedDependencies = dependenciesData.filter(dep => String(dep.FeatureID) === featureIdStr);

        associatedUserStories.sort((a, b) => {
          const sprintA = String(a.Sprint || '').trim();
          const sprintB = String(b.Sprint || '').trim();
          const nameA = String(a.Name || '').toLowerCase();
          const nameB = String(b.Name || '').toLowerCase();

          if (sprintA !== sprintB) {
            const numA = parseInt(sprintA.replace(/[^0-9]/g, ''), 10);
            const numB = parseInt(sprintB.replace(/[^0-9]/g, ''), 10);
            if (!isNaN(numA) && !isNaN(numB) && numA !== numB) {
              return numB - numA;
            }
            return sprintB.localeCompare(sprintA, undefined, {numeric: true, sensitivity: 'base'});
          }
          return nameB.localeCompare(nameA);
        });

        associatedDependencies.sort((a, b) => {
          const sprintA = String(a.Sprint || '').trim();
          const sprintB = String(b.Sprint || '').trim();
          const nameA = String(a.Name || '').toLowerCase();
          const nameB = String(b.Name || '').toLowerCase();

          if (sprintA !== sprintB) {
            const numA = parseInt(sprintA.replace(/[^0-9]/g, ''), 10);
            const numB = parseInt(sprintB.replace(/[^0-9]/g, ''), 10);
            if (!isNaN(numA) && !isNaN(numB) && numA !== numB) {
              return numB - numA;
            }
            return sprintB.localeCompare(sprintA, undefined, {numeric: true, sensitivity: 'base'});
          }
          return nameB.localeCompare(nameA);
        });

        return {
          ...feature,
          userStories: associatedUserStories,
          dependencies: associatedDependencies,
          userStoryCount: associatedUserStories.length,
          dependencyCount: associatedDependencies.length
        };
      });
    }

    const calculatePodium = (items, itemType = 'item') => { // A침adido itemType para loggeo
      const podium = [];
      if (items && items.length > 0) {
        const responsibles = [...new Set(items.map(item => item.Responsible).filter(Boolean))];
        responsibles.forEach(responsible => {
          const responsibleItems = items.filter(item => item.Responsible === responsible);
          const totalItems = responsibleItems.length;
          if (totalItems > 0) {
            const deployedItems = responsibleItems.filter(item => String(item.Status).trim().toLowerCase() === 'deployed').length;
            podium.push({
              responsible: responsible,
              progress: Math.round((deployedItems / totalItems) * 100),
              deployedItems: deployedItems, // Requerimiento Podios
              totalItems: totalItems        // Requerimiento Podios
            });
          }
        });
        podium.sort((a, b) => b.progress - a.progress);
      }
      // Logger.log(`Podium para ${itemType}: ${JSON.stringify(podium)}`);
      return podium;
    };

    const podiumDataFeatures = calculatePodium(featuresData, 'Features');
    const podiumDataUserStories = calculatePodium(userStoriesData, 'UserStories');
    const podiumDataDependencies = calculatePodium(dependenciesData, 'Dependencies');

    const allQsList = [...new Set(featuresData.map(f => f.Q).filter(Boolean))].sort();
    const allSprintsList = [...new Set(
      [
        ...userStoriesData.map(us => us.Sprint),
        ...dependenciesData.map(dep => dep.Sprint)
      ].filter(Boolean)
    )].sort((a, b) => {
        const numA = parseInt(String(a).replace(/[^0-9]/g, ''), 10);
        const numB = parseInt(String(b).replace(/[^0-9]/g, ''), 10);
        if (!isNaN(numA) && !isNaN(numB) && numA !== numB) {
            return numA - numB;
        }
        return String(a).localeCompare(String(b), undefined, {numeric: true, sensitivity: 'base'});
    });


    const upcomingEvents = getUpcomingEventsFromSheet(config.CALENDAR_ID_SHEET, config.MAX_CALENDAR_EVENTS);

    const dataToReturn = {
      error: null,
      features: featuresData,
      announcements: announcementsToClient,
      config: config,
      quickLinks: quickLinksData,
      impediments: impedimentsData.sort((a, b) => new Date(b.Timestamp) - new Date(a.Timestamp)),
      currentUserEmail: getActiveUserEmailSafely(),
      podiumDataFeatures: podiumDataFeatures,
      podiumDataUserStories: podiumDataUserStories,
      podiumDataDependencies: podiumDataDependencies,
      availableQs: allQsList,
      availableSprints: allSprintsList,
      allFeaturesForImpediments: allFeaturesForImpediments,
      nonDeployedUserStories: nonDeployedUserStories,
      upcomingEvents: upcomingEvents,
      communications: communicationsData
    };

    return dataToReturn;

  } catch (error) {
    Logger.log(`Error en getAllSheetData: ${error.toString()} ${error.stack}`);
    console.error(`Error en getAllSheetData: ${error.toString()} ${error.stack}`);
    return { ...defaultReturnValue, error: `Error en getAllSheetData: ${error.toString()}` };
  }
}

/**
 * Obtiene el email del usuario activo de forma segura.
 * @return {string|null} El email del usuario o null si no se puede obtener.
 */
function getActiveUserEmailSafely() {
  try {
    return Session.getActiveUser() ? Session.getActiveUser().getEmail() : null;
  } catch (e) {
    Logger.log("No se pudo obtener email: " + e.toString());
    return null;
  }
}

/**
 * Obtiene el mood general del equipo para el d칤a actual.
 * @return {string} El emoji del mood m치s frecuente.
 */
function getTeamMood() {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const moodSheet = ss.getSheetByName(MOODS_SHEET_NAME);
    if (!moodSheet || moodSheet.getLastRow() < 2) {
      Logger.log("Hoja de Moods no encontrada o vac칤a.");
      return APP_CONFIG_DEFAULTS.TEAM_MOOD_DEFAULT_EMOJI || "游땕";
    }

    const data = moodSheet.getRange(2, 1, moodSheet.getLastRow() - 1, 3).getValues();
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const todaysMoods = data.filter(row => {
      if (!row[0] || !row[2]) return false;
      const timestamp = new Date(row[0]);
      timestamp.setHours(0, 0, 0, 0);
      return timestamp.getTime() === today.getTime();
    });

    if (todaysMoods.length === 0) {
      Logger.log("No hay moods para hoy.");
      return APP_CONFIG_DEFAULTS.TEAM_MOOD_DEFAULT_EMOJI || "游땕";
    }

    const moodCounts = todaysMoods.reduce((acc, row) => {
      const mood = row[2];
      acc[mood] = (acc[mood] || 0) + 1;
      return acc;
    }, {});

    let mostFrequentMood = APP_CONFIG_DEFAULTS.TEAM_MOOD_DEFAULT_EMOJI || "游땕";
    let maxCount = 0;
    for (const mood in moodCounts) {
      if (moodCounts[mood] > maxCount) {
        mostFrequentMood = mood;
        maxCount = moodCounts[mood];
      }
    }
    Logger.log(`Mood m치s frecuente de hoy: ${mostFrequentMood} (conteo: ${maxCount})`);
    return mostFrequentMood;

  } catch (error) {
    Logger.log(`Error en getTeamMood: ${error.toString()}`);
    return APP_CONFIG_DEFAULTS.TEAM_MOOD_DEFAULT_EMOJI || "游땕";
  }
}

/**
 * Guarda el mood del usuario.
 * @param {string} moodEmoji - El emoji seleccionado por el usuario.
 * @return {Object} Resultado de la operaci칩n.
 */
function saveUserMood(moodEmoji) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const moodSheet = ss.getSheetByName(MOODS_SHEET_NAME);
    if (!moodSheet) throw new Error(`Hoja '${MOODS_SHEET_NAME}' no encontrada.`);

    moodSheet.appendRow([new Date(), getActiveUserEmailSafely(), moodEmoji]);
    Logger.log(`Mood guardado: ${moodEmoji}`);
    const newTeamMood = getTeamMood();
    return { success: true, message: 'Mood guardado.', newTeamMood: newTeamMood };
  } catch (error) {
    Logger.log(`Error en saveUserMood: ${error.toString()}`);
    return { success: false, message: `Error al guardar mood: ${error.toString()}` };
  }
}

/**
 * Guarda un nuevo impedimento y notifica por email.
 * @param {Object} impedimentData - Datos del impedimento (title, description, associatedFeatureID, associatedUserStoryID).
 * @return {Object} Resultado de la operaci칩n.
 */
function saveImpediment(impedimentData) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const impedimentsSheet = ss.getSheetByName(IMPEDIMENTS_SHEET_NAME);
    if (!impedimentsSheet) throw new Error(`Hoja '${IMPEDIMENTS_SHEET_NAME}' no encontrada. Por favor, cr칠ala.`);

    const userEmail = getActiveUserEmailSafely();
    const timestamp = new Date();
    const status = "Nuevo";
    const associatedFeatureID = impedimentData.associatedFeatureID || null;
    const associatedUserStoryID = impedimentData.associatedUserStoryID || null;
    const title = impedimentData.title;

    impedimentsSheet.appendRow([
      timestamp,
      userEmail,
      title,
      impedimentData.description,
      status,
      associatedUserStoryID,
      associatedFeatureID
    ]);
    Logger.log(`Impedimento guardado por ${userEmail}: "${title}", F: ${associatedFeatureID}, HU: ${associatedUserStoryID}`);

    const configSheet = ss.getSheetByName(CONFIG_SHEET_NAME);
    let notificationEmail = APP_CONFIG_DEFAULTS.IMPEDIMENT_NOTIFICATION_EMAIL;
    if (configSheet) {
      const configData = getSheetDataAsObjects(configSheet, CONFIG_SHEET_NAME);
      const emailConfig = configData.find(item => item.Key === 'IMPEDIMENT_NOTIFICATION_EMAIL');
      if (emailConfig && emailConfig.Value) {
        notificationEmail = emailConfig.Value;
      }
    }

    if (notificationEmail) {
      try {
        let emailBody = `Se ha registrado un nuevo impedimento:\n\nT칤tulo (HU/Feature): ${title}\nDescripci칩n: ${impedimentData.description}\n`;
        if (associatedFeatureID) {
          emailBody += `ID Feature Asociada: ${associatedFeatureID}\n`;
        }
        if (associatedUserStoryID) {
          emailBody += `ID Historia de Usuario Asociada: ${associatedUserStoryID}\n`;
        }
        emailBody += `\nPor: ${userEmail || 'N/A'}\nFecha: ${timestamp.toLocaleString()}\nEstado: ${status}`;

        MailApp.sendEmail({
          to: notificationEmail,
          subject: `Impedimento: ${title}`,
          body: emailBody
        });
        Logger.log(`Notificaci칩n de impedimento enviada a: ${notificationEmail}`);
      } catch (e) {
        Logger.log(`Error al enviar email de notificaci칩n de impedimento: ${e.toString()}`);
      }
    } else {
      Logger.log("Email de notificaci칩n de impedimentos no configurado en la hoja Config.");
    }

    const newImpediment = {
      Timestamp: timestamp.toISOString(),
      UserEmail: userEmail,
      Title: title,
      Description: impedimentData.description,
      Status: status,
      AssociatedUserStoryID: associatedUserStoryID,
      AssociatedFeatureID: associatedFeatureID
    };
    return { success: true, message: 'Impedimento guardado.', impediment: newImpediment };
  } catch (error) {
    Logger.log(`Error en saveImpediment: ${error.toString()}`);
    return { success: false, message: `Error al guardar impedimento: ${error.toString()}` };
  }
}

/**
 * Obtiene los pr칩ximos eventos de una hoja de c치lculo.
 * @param {string} sheetName - El nombre de la hoja que contiene los eventos.
 * @param {number} maxEvents - El n칰mero m치ximo de eventos a obtener.
 * @return {Array} Una lista de objetos de evento.
 */
function getUpcomingEventsFromSheet(sheetName, maxEvents) {
  if (!sheetName) {
    Logger.log("Nombre de hoja para eventos no configurado. No se pueden obtener eventos.");
    return [];
  }
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const eventSheet = ss.getSheetByName(sheetName);
    if (!eventSheet) {
      Logger.log(`Hoja de eventos '${sheetName}' no encontrada.`);
      return [];
    }
    const eventsData = getSheetDataAsObjects(eventSheet, sheetName);
    const now = new Date();

    const formattedEvents = eventsData
      .filter(event => {
        if (!event.StartDate) return false;
        try {
          const startDate = new Date(event.StartDate);
          return startDate >= now;
        } catch (e) {
          Logger.log(`Fecha inv치lida para evento '${event.EventTitle || event.title}': ${event.StartDate}`);
          return false;
        }
      })
      .sort((a, b) => new Date(a.StartDate) - new Date(b.StartDate))
      .slice(0, maxEvents)
      .map(event => {
        let startISO = event.StartDate;
        let endISO = event.EndDate;
        if (event.StartDate instanceof Date) startISO = event.StartDate.toISOString();
        if (event.EndDate instanceof Date) endISO = event.EndDate.toISOString();

        return {
          title: event.EventTitle || event.title || 'Evento sin t칤tulo',
          start: startISO,
          end: endISO,
          fullday: event.AllDayEvent === true || String(event.AllDayEvent).toLowerCase() === 'true'
        };
      });
    Logger.log(`Eventos obtenidos de la hoja '${sheetName}': ${formattedEvents.length}`);
    return formattedEvents;
  } catch (e) {
    Logger.log(`Error al obtener eventos de la hoja '${sheetName}': ${e.toString()}`);
    return [];
  }
}


/**
 * Convierte los datos de una hoja en un array de objetos.
 * @param {SpreadsheetApp.Sheet} sheet - El objeto de la hoja de c치lculo.
 * @param {string} sheetName - El nombre de la hoja (para logging y mapeo espec칤fico).
 * @return {Array<Object>} Un array de objetos representando las filas.
 */
function getSheetDataAsObjects(sheet, sheetName) {
  if (!sheet) return [];
  const numRows = sheet.getLastRow();
  if (numRows < 1) return [];
  const lastColumn = sheet.getLastColumn();
  if (lastColumn === 0) return [];

  const values = sheet.getRange(1, 1, numRows, lastColumn).getValues();
  if (values.length < 1) return [];

  const headers = values[0].map(header => {
    let pHeader = String(header || "").trim();
    if (pHeader === "Status Order") pHeader = "StatusOrder";
    else if (pHeader === "Jira Link") pHeader = "JiraLink";
    else if (pHeader === "Feature ID") pHeader = "FeatureID";
    else if (pHeader === "Tag Class") pHeader = "TagClass";
    else if (pHeader === "Seguimiento") pHeader = "Responsible";
    else if (pHeader === "Show" || pHeader === "Mostrar") pHeader = "Show";
    else if (sheetName === ANNOUNCEMENTS_SHEET_NAME && pHeader === "Announcements: Text") pHeader = "Text";
    else if (sheetName === QUICKLINKS_SHEET_NAME && pHeader === "Text") pHeader = "Text";
    else if (sheetName === QUICKLINKS_SHEET_NAME && pHeader === "URL") pHeader = "URL";
    else if (pHeader === "Favorite") pHeader = "Favorite";
    else if (pHeader === "Q" || pHeader === "Quarter") pHeader = "Q";
    else if (pHeader === "Sprint" || pHeader === "Sprint Number") pHeader = "Sprint";
    else if (pHeader === "Priority") pHeader = "Priority";
    else if (sheetName === IMPEDIMENTS_SHEET_NAME && pHeader === "Title") pHeader = "Title";
    else if (sheetName === IMPEDIMENTS_SHEET_NAME && pHeader === "Description") pHeader = "Description";
    else if (sheetName === IMPEDIMENTS_SHEET_NAME && pHeader === "Status") pHeader = "Status";
    else if (sheetName === IMPEDIMENTS_SHEET_NAME && pHeader === "UserEmail") pHeader = "UserEmail";
    else if (sheetName === IMPEDIMENTS_SHEET_NAME && pHeader === "Timestamp") pHeader = "Timestamp";
    else if (sheetName === IMPEDIMENTS_SHEET_NAME && pHeader === "AssociatedUserStoryID") pHeader = "AssociatedUserStoryID";
    else if (sheetName === IMPEDIMENTS_SHEET_NAME && pHeader === "AssociatedFeatureID") pHeader = "AssociatedFeatureID";
    else if (sheetName === UPCOMING_EVENTS_SHEET_NAME && (pHeader === "Event Title" || pHeader === "Title")) pHeader = "EventTitle";
    else if (sheetName === UPCOMING_EVENTS_SHEET_NAME && (pHeader === "Start Date" || pHeader === "StartDate")) pHeader = "StartDate";
    else if (sheetName === UPCOMING_EVENTS_SHEET_NAME && (pHeader === "End Date" || pHeader === "EndDate")) pHeader = "EndDate";
    else if (sheetName === UPCOMING_EVENTS_SHEET_NAME && (pHeader === "All Day Event" || pHeader === "AllDayEvent")) pHeader = "AllDayEvent";
    else if (sheetName === COMMUNICATIONS_SHEET_NAME && pHeader === "Fecha") pHeader = "Date";
    else if (sheetName === COMMUNICATIONS_SHEET_NAME && (pHeader === "Comunicado" || pHeader === "Mensaje")) pHeader = "Message";
    else if (sheetName === COMMUNICATIONS_SHEET_NAME && pHeader === "URL") pHeader = "URL";

    pHeader = pHeader.replace(/[^a-zA-Z0-9_ ]/g, '').replace(/\s+/g, '');
    return pHeader;
  });

  const objects = [];
  if (numRows < 2) return [];

  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const object = {};
    let hasData = false;
    headers.forEach((header, index) => {
      if (!header) return;
      let cellVal = row[index];

      if (cellVal instanceof Date) {
        if (((sheetName === IMPEDIMENTS_SHEET_NAME || sheetName === MOODS_SHEET_NAME) && header === 'Timestamp') ||
          ((sheetName === UPCOMING_EVENTS_SHEET_NAME || sheetName === COMMUNICATIONS_SHEET_NAME) && (header === 'StartDate' || header === 'EndDate' || header === 'Date'))
        ) {
          object[header] = cellVal;
        } else {
          object[header] = Utilities.formatDate(cellVal, Session.getScriptTimeZone(), "yyyy-MM-dd'T'HH:mm:ss'Z'");
        }
      } else {
        if (((sheetName === UPCOMING_EVENTS_SHEET_NAME || sheetName === COMMUNICATIONS_SHEET_NAME) && (header === 'StartDate' || header === 'EndDate' || header === 'Date') && cellVal)) {
          try {
            let parsedDate = new Date(cellVal);
            if (isNaN(parsedDate.getTime())) {
              if (String(cellVal).includes('/')) {
                const parts = String(cellVal).split('/');
                if (parts.length === 3) {
                    let day, month, year;
                    year = parseInt(parts[2], 10);
                    if (parseInt(parts[0], 10) > 12 && parseInt(parts[1], 10) <= 12) {
                        day = parseInt(parts[0], 10);
                        month = parseInt(parts[1], 10);
                    } else if (parseInt(parts[1], 10) > 12 && parseInt(parts[0], 10) <= 12) {
                        day = parseInt(parts[1], 10);
                        month = parseInt(parts[0], 10);
                    } else {
                        month = parseInt(parts[0], 10);
                        day = parseInt(parts[1], 10);
                        if (month > 12) {
                            month = parseInt(parts[1], 10);
                            day = parseInt(parts[0], 10);
                        }
                    }
                    if (day && month && year) {
                         parsedDate = new Date(year, month - 1, day);
                    }
                }
              }
            }

            if (isNaN(parsedDate.getTime())) {
              Logger.log(`Fecha string inv치lida en ${sheetName}, header ${header}: ${cellVal}. Se mantiene como string.`);
              object[header] = cellVal;
            } else {
              object[header] = parsedDate;
            }

          } catch (e) {
            Logger.log(`Error parseando fecha string en ${sheetName}, header ${header}: ${cellVal} - ${e}`);
            object[header] = cellVal;
          }
        } else {
          object[header] = cellVal;
        }
      }

      if (cellVal !== "" && cellVal !== null && typeof cellVal !== 'undefined') hasData = true;

      if (header === 'StatusOrder' || header === 'Order') {
        const numVal = parseFloat(cellVal);
        object[header] = (cellVal !== "" && cellVal !== null && !isNaN(numVal)) ? numVal : null;
      } else if (header === 'ID' || header === 'FeatureID' || header === 'AssociatedUserStoryID' || header === 'AssociatedFeatureID' || header === 'Sprint') {
        object[header] = (cellVal !== "" && cellVal !== null) ? String(cellVal).trim() : null;
      } else if (header === 'Show' || header === 'Favorite' || header === 'AllDayEvent') {
        object[header] = (String(cellVal).trim().toLowerCase() === 'true' || cellVal === true);
      }
    });
    if (hasData) {
      if (object.Timestamp instanceof Date) object.Timestamp = object.Timestamp.toISOString();
      if (object.StartDate instanceof Date) object.StartDate = object.StartDate.toISOString();
      if (object.EndDate instanceof Date) object.EndDate = object.EndDate.toISOString();
      if (object.Date instanceof Date) object.Date = object.Date.toISOString();

      objects.push(object);
    }
  }
  return objects;
}
